# JavaScript 中的正则表达式

正则表达式（*Regular Expression*，一般简写为 *regex*，*regexp*）

> 正则表达式描述了**一种字符串匹配的模式**（*pattern*），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

## 一、正则表达式基本语法

### 基本匹配

<pre>
"student" => I am a <a><strong>student</strong></a>.  
</pre>
注意**大小写不敏感**，*student* 不会匹配到 *Student*

### 元字符

元字符是**用以匹配特定的字符**（字母，数字，符号），注意字母是**区分大小写**的：

| 元字符   | 描述                                                         | 举例                                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ |
| `.`      | 句号匹配除换行符 `\n` 外任意单个字符                         | `.at` => e<a>at</a> and f<a>at</a>.              |
| `[ ]`    | 字符种类，匹配方括号内的任意字符                             | `[a-z]` => 'a' 到 'z' 范围内的任意小写字母字符   |
| `[^ ]`   | 否定的字符种类，匹配除了方括号里的任意字符                   | `[^a-z]` => 任何不在 'a' 到 'z' 范围内的任意字符 |
| `*`      | 匹配前面的子表达式**零次或多次**，等价于 `{0,}`              | `zo*` => <a>zo</a>、<a>zoo</a> and <a>z</a>      |
| `+`      | 匹配前面的子表达式**一次或多次**，等价于 `{1,}`              | `zo+` => <a>zo</a>、<a>zoo</a> and z             |
| `?`      | 匹配前面的子表达式**零次或一次**，等价于 `{0,1}`             | `do(es)?` => <a>do</a> or <a>does</a>            |
| `^`      | 从**首端**开始匹配                                           |                                                  |
| `$`      | 从**末端**开始匹配                                           |                                                  |
| `(xyz)`  | 字符集，匹配与 xyz 完全相等的字符串                          |                                                  |
| `|`      | 或运算符，匹配符号前或后的字符                               |                                                  |
| `\`      | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。 |                                                  |
| `\d`     | 匹配一个**数字字符**，等价于 `[0-9]`                         |                                                  |
| `\D`     | 匹配一个**非数字字符**，等价于 `[^0-9]`                      |                                                  |
| `\w`     | 匹配**字母、数字、下划线**，等价于 `[A-Za-z0-9_]`            |                                                  |
| `\W`     | 匹配**非字母、数字、下划线**，等价于 `[^A-Za-z0-9_]`         |                                                  |
| `\s`     | 匹配**任意空白字符**，相当于 `[\t\n\r\f\v]`                  |                                                  |
| `\S`     | 匹配**非空白字符**，相当于 `[^\t\n\r\f\v]`                   |                                                  |
| `\b`     | 匹配**边界**，字符串的开头结尾，空格的两边都是边界 => 不占用字符串位数 |                                                  |
| `()`     | 分组                                                         |                                                  |
| `{}`     | 量词，常用来限定一个或一组字符可以重复出现的次数             |                                                  |
| `{n}`    | 正好 n 次                                                    |                                                  |
| `{n,}`   | n到多次                                                      |                                                  |
| `{n,m} ` | n次到m次                                                     |                                                  |

### 正则表达式的特性

- **贪婪性**：正则在捕获时，默认是贪婪的，每一次会尽可能多的去捕获符合条件的内容；
- **懒惰性**：正则在成功捕获一次后，不管后边的字符串有没有符合条件的都不再捕获。

## 二、Javascript 中正则表达式的使用

### 创建一个正则表达式的两种方式

*Javascript* 中，创建一个正则表达式有两种方式：

- 使用字面量创建
- 使用 `RegExp()` 构造方法创建一个正则表达式实例

```javascript
const reg1 = /pattern/flags;
const reg2 = new RegExp(pattern, flags);
```

这两种方式的**区别**：

- 字面量创建方式不能进行字符串拼接，实例创建方式可以

- 字面量创建方式特殊含义的字符不需要转义，实例创建方式需要转义

### 正则方法

| 方法       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| `exec`     | 一个在字符串中执行查找匹配的 *RegExp* 方法，它**返回一个数组**（未匹配到则返回 `null`） |
| `test`     | 一个在字符串中测试是否匹配的 *RegExp* 方法，它返回 `true` 或 `false` |
| `match`    | 一个在字符串中执行查找匹配的 *String* 方法，它**返回一个数组**，在未匹配到时会返回 `null` |
| `matchAll` | 一个在字符串中执行查找所有匹配的 *String* 方法，它**返回一个迭代器** `iterator` |
| `search`   | 一个在字符串中测试匹配的 *String* 方法，它**返回匹配到的位置索引**，或者在失败时返回 -1 |
| `replace`  | 一个在字符串中执行查找匹配的 *String* 方法，并且**使用替换字符串替换掉匹配到的子字符串** |
| `split`    | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 *String* 方法 |

下面简单介绍其中几个正则方法：

#### 1、`reg.test(str)`

用来**验证字符串是否符合正则**，符合返回 `true`，否则返回 `false`

```javascript
const str = "string";
const reg = /\w+/;
console.log(reg.test(str)); // true
```

#### 2、`reg.exec(str)`

用来**捕获符合规则的字符串**

#### 3、`str.match(reg)`

如果匹配成功，则匹配成功的数组，如果匹配不成功，则返回 `null`

#### 4、`str.replace(reg, newStr)`

正则去匹配字符串，匹配成功的字符替换成新的字符串

## 三、常用的正则表达式

#### 姓名

```javascript
/^[u4e00-u9fa5]{2,4}$/  //2-4个中文字符正则
```

#### 手机号码

```javascript
/^(13[0-9]|14[01456879]|15[0-3,5-9]|16[2567]|17[0-8]|18[0-9]|19[0-3,5-9])d{8}$/
```

#### 座机号码

```javascript
/^(0d{2,3})-?(d{7,8})$/
```

#### 电子邮箱

```javascript
/^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$/
```

#### 身份证号码

```javascript
/(^d{15}$)|(^d{18}$)|(^d{17}(d|X|x)$)/
```

#### QQ 号码

```javascript
/^[1-9][0-9]d{4,9}$/
```

#### 邮政编码

```javascript
/^[1-9]d{5}$/
```

## 四、总结

> 本文主要是笔记记录，引用来自 
>
> - [https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#learn-regex](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#learn-regex)
> - [https://www.runoob.com/regexp/regexp-metachar.html](https://www.runoob.com/regexp/regexp-metachar.html)
> - [https://www.cnblogs.com/lnlvinso/p/10467941.html](https://www.cnblogs.com/lnlvinso/p/10467941.html)
> - [https://blog.csdn.net/snshl9db69ccu1aikl9r/article/details/114421022](https://blog.csdn.net/snshl9db69ccu1aikl9r/article/details/114421022)

